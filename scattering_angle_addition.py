# -*- coding: utf-8 -*-
"""scattering angle addition

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZLfAfvX06xRpLLiGo3OyhV9fAN2J2chT
"""

import numpy as np
import matplotlib.pyplot as plt
from math import sqrt


# Parameters (normalized units)
dt = 1e-3
n_steps = 15000
B = 2.0
q = -1.0         # charge
m = 1.0
gamma0 = 10.0

# Initial momentum
v0 = sqrt(1 - 1/gamma0**2)
p = np.array([0.4 * gamma0 * v0, 0.0, 0.9 * gamma0 * v0])
x = np.zeros(3)

# Monte Carlo interaction parameters
mean_free_path = 2.0
energy_loss_fraction = 0.1
scatter_angle_rms = 0.4  # radians

# Storage
traj = np.zeros((n_steps, 3))
gamma_hist = np.zeros(n_steps)
z_vals = []
interaction_steps = []

def gamma(p):
    return np.sqrt(1 + np.dot(p, p))

def velocity(p):
    return p / gamma(p)

def boris_push(p, B, dt):
    t = q * B * dt / 2
    s = 2 * t / (1 + t*t)
    p_minus = p
    p_prime = p_minus + np.cross(p_minus, t)
    return p_minus + np.cross(p_prime, s)

# seed for reproducibility
#np.random.seed(0)

remaining_path = np.random.exponential(mean_free_path)

for i in range(n_steps):
    traj[i] = x
    g = gamma(p)
    gamma_hist[i] = g

    # Magnetic field along y
    p = boris_push(p, np.array([0, B, 0]), dt)

    v = velocity(p)
    x += v * dt

    dz = abs(v[2]) * dt
    remaining_path -= dz

    if remaining_path <= 0:
        # record step
        interaction_steps.append(i)

        # energy loss (scale momentum magnitude)
        E_kin = g - 1
        dE = energy_loss_fraction * E_kin
        new_g = max(1.0, g - dE)
        scale = np.sqrt((new_g**2 - 1) / (g**2 - 1)) if g > 1 else 0.0
        if scale > 0:
            p *= scale

        # --- scattering: rotate p about a random axis perpendicular to p ---
        theta = np.random.normal(0.0, scatter_angle_rms)
        u = p / (np.linalg.norm(p) + 1e-12)
        randv = np.random.randn(3)
        perp = randv - np.dot(randv, u) * u
        if np.linalg.norm(perp) > 1e-12:
            perp /= np.linalg.norm(perp)
            # Rodrigues rotation
            p = (p * np.cos(theta) +
                 np.cross(perp, p) * np.sin(theta) +
                 perp * np.dot(perp, p) * (1 - np.cos(theta)))

        z_vals.append(x[2])
        remaining_path = np.random.exponential(mean_free_path)

# Plot: trajectory x vs z with interaction markers
plt.figure(figsize=(6,4))
plt.plot(traj[:,2], traj[:,0], label='trajectory')
if len(z_vals) > 0:
    ints = [np.argmin(np.abs(traj[:,2]-z)) for z in z_vals]
    plt.scatter(traj[ints,2], traj[ints,0], color='red', s=30, label='interactions')
plt.xlabel("z")
plt.ylabel("x")
plt.title("Trajectory x vs z with interactions marked")
plt.grid(True)
plt.legend()
plt.show()

# Plot: gamma vs step with interaction markers
plt.figure(figsize=(6,4))
plt.plot(gamma_hist, label='gamma')
if len(interaction_steps) > 0:
    plt.scatter(interaction_steps, gamma_hist[interaction_steps], color='red', s=20, label='interactions')
plt.xlabel("step")
plt.ylabel("gamma")
plt.title("Energy evolution (gamma) with discrete losses")
plt.grid(True)
plt.legend()
plt.show()

# Plot: histogram of interaction z
plt.figure(figsize=(6,4))
plt.hist(z_vals, bins=40)
plt.xlabel("z (interaction depth)")
plt.ylabel("counts")
plt.title("Interaction depth histogram")
plt.grid(True)
plt.show()